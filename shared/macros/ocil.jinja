{{#
    How to log in to a Red Hat CoreOS Node
#}}
{{% macro rhcos_node_login_instructions() -%}}
    As a user with administrator privileges, log into a node in the relevant pool:
    <pre>
    $ oc debug node/$NODE_NAME
    </pre>
    At the <pre>sh-4.4#</pre> prompt, run:
    <pre>
    # chroot /host
    </pre>
{{% endmacro %}}


{{# Audit macros #}}

{{#
    OCIL for adding a syscall to audit logs

:param syscall: The syscall to audit
:type syscall: str

#}}
{{% macro ocil_audit_syscall(syscall) -%}}
    To determine if the system is configured to audit calls to the
    <code>{{{ syscall }}}</code> system call, run the following command:
    <pre space="preserve">$ sudo grep "{{{ syscall }}}" /etc/audit/audit.*</pre>
    If the system is configured to audit this activity, it will return a line.
{{%- endmacro %}}


{{#
    OCIL clause for adding a syscall to audit logs
#}}
{{% macro ocil_clause_entry_audit_syscall() -%}}
ocil_clause: "no line is returned"
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for adding a syscall to audit logs

:param syscall: The syscall to audit
:type syscall: str

#}}
{{% macro complete_ocil_entry_audit_syscall(syscall) -%}}
ocil: |
    {{{ ocil_audit_syscall(syscall) }}}

{{{ ocil_clause_entry_audit_syscall() }}}
{{%- endmacro %}}


{{#
    OCIL for adding a successful syscall to audit logs

:param syscall: The syscall to audit
:type syscall: str

#}}
{{% macro ocil_audit_successful_syscall(syscall) -%}}
    To determine if the system is configured to audit successful calls
    to the <code>{{{ syscall }}}</code> system call, run the following command:
    <pre space="preserve">$ sudo grep "{{{ syscall }}}" /etc/audit.*</pre>
    If the system is configured to audit this activity, it will return a line.
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for adding a successful syscall to audit logs

:param syscall: The syscall to audit
:type syscall: str

#}}
{{% macro complete_ocil_entry_audit_successful_syscall(syscall) -%}}
ocil: |
    {{{ ocil_audit_successful_syscall(syscall) }}}

{{{ ocil_clause_entry_audit_syscall() }}}
{{%- endmacro %}}


{{# Package macros #}}

{{#
    Describe how to check if a package is installed with rpm.

:param package: The package to check
:type package: str

#}}
{{%- macro rpm_ocil_package(package) -%}}
    Run the following command to determine if the <code>{{{ package }}}</code> package is installed:
    <pre>$ rpm -q {{{ package }}}</pre>
{{%- endmacro -%}}


{{#
    Describe how to check if a package is installed with dpkg.

:param package: The package to check
:type package: str

#}}
{{%- macro dpkg_ocil_package(package) %}}
    Run the following command to determine if the <code>{{{ package }}}</code> package is installed:
    <pre>$ dpkg -l  {{{ package }}}</pre>
{{%- endmacro %}}


{{#
    Insert general ocil clause to check if a package is installed, substituting the
    correct package management software.

:param package: Name of package
:type package: str

#}}
{{% macro ocil_package(package) -%}}
  {{% if pkg_system is defined %}}
    {{%- if pkg_system == "rpm" -%}}
        {{{ rpm_ocil_package(package) }}}
    {{%- elif pkg_system == "dpkg" -%}}
        {{{ dpkg_ocil_package(package) }}}
    {{%- else -%}}
JINJA MACRO ERROR - Unknown package system '{{{ pkg_system }}}'.
    {{%- endif -%}}
  {{%- endif -%}}
{{%- endmacro %}}


{{#
    OCIL and OCIL clause how to check if a package is installed with rpm.

:param package: The package to check
:type package: str

#}}
{{%- macro rpm_complete_ocil_entry_package(package) %}}
ocil: |-
    {{{ rpm_ocil_package(package) }}}

ocil_clause: "the package is installed"
{{%- endmacro %}}


{{#
    OCIL and OCIL clause how to check if a package is installed with dpkg.

:param package: The package to check
:type package: str
#}}
{{%- macro dpkg_complete_ocil_entry_package(package) %}}
ocil: |-
    {{{ dpkg_ocil_package(package) }}}

ocil_clause: "the package is installed"
{{%- endmacro %}}


{{#
    Insert a complete OCIL block for a case when a package should be removed,
    substituting the correct package management software.

:param package: Name of package
:type package: str

#}}
{{% macro complete_ocil_entry_package(package) -%}}
  {{% if pkg_system is defined %}}
    {{%- if pkg_system == "rpm" %}}
        {{{ rpm_complete_ocil_entry_package(package) }}}
    {{%- elif pkg_system == "dpkg" %}}
        {{{ dpkg_complete_ocil_entry_package(package) }}}
    {{%- else -%}}
ocil: |-
    JINJA MACRO ERROR - Unknown package system '{{{ pkg_system }}}'.
    {{%- endif -%}}
  {{%- endif -%}}
{{%- endmacro %}}


{{# Service Enabled macros #}}

{{#
    Describe how to check if a service is enabled via systemd.

:param service: The service to check
:type service: str

#}}
{{%- macro systemd_ocil_service_enabled(service) %}}
    {{% if product == "rhcos4" -%}}
    {{{ rhcos_node_login_instructions() }}}
    {{%- endif %}}
    Run the following command to determine the current status of the
    <code>{{{ service }}}</code> service:
    <pre>$ systemctl is-active {{{ service }}}</pre>
    If the service is running, it should return the following: <pre>active</pre>
{{%- endmacro %}}


{{#
    Describe how to check if a service is enabled via upstart.

:param service: The service to check
:type service: str

#}}
{{%- macro upstart_ocil_service_enabled(service) %}}
    Run the following command to determine the current status of the
    <code>{{{ service }}}</code> service:
    <pre>$ sudo service {{{ service }}} status</pre>
    If the service is enabled, it should return the following: <pre>{{{ service }}} is running...</pre>
{{%- endmacro %}}


{{#
    Inserts an OCIL for a case when a service should be enabled,
    substituting the correct init system.

:param service: Name of service
:type service: str

#}}
{{% macro ocil_service_enabled(service) -%}}
  {{% if init_system is defined %}}
    {{%- if init_system == "systemd" -%}}
        {{{ systemd_ocil_service_enabled(service) }}}
    {{%- elif init_system == "upstart" -%}}
        {{{ upstart_ocil_service_enabled(service) }}}
    {{%- else -%}}
JINJA MACRO ERROR - Unknown init system '{{{ init_system }}}'.
    {{%- endif -%}}
  {{%- endif -%}}
{{%- endmacro %}}


{{# Service Disabled macros #}}

{{#
    Describe how to check if a service is disabled via systemd.

:param service: The service to check
:type service: str

#}}
{{%- macro systemd_ocil_service_disabled(service) %}}
    To check that the <code>{{{ service }}}</code> service is disabled in system boot configuration,
    {{% if product == "rhcos4" -%}}
    You'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Subsequently,
    {{%- endif -%}}
    run the following command:
    <pre>$ systemctl is-enabled <code>{{{ service }}}</code></pre>
    Output should indicate the <code>{{{ service }}}</code> service has either not been installed,
    or has been disabled at all runlevels, as shown in the example below:
    <pre>$ systemctl is-enabled <code>{{{ service }}}</code><br/> disabled</pre>

    Run the following command to verify <code>{{{ service }}}</code> is not active (i.e. not running) through current runtime configuration:
    <pre>$ systemctl is-active {{{ service }}}</pre>

    If the service is not running the command will return the following output:
    <pre>inactive</pre>

    The service will also be masked, to check that the <code>{{{ service }}}</code> is masked, run the following command:
    <pre>$ systemctl show <code>{{{ service }}}</code> | grep "LoadState\|UnitFileState"</pre>

    If the service is masked the command will return the following outputs:

    <pre>LoadState=masked</pre>

    <pre>UnitFileState=masked</pre>

{{%- endmacro %}}


{{#
    Describe how to check if a service is disabled via upstart.

:param service: The service to check
:type service: str

#}}
{{%- macro upstart_ocil_service_disabled(service) %}}
    To check that the <code>{{{ service }}}</code> service is disabled in system boot configuration, run the following command:
    <pre>$ sudo chkconfig <code>{{{ service }}}</code> --list</pre>
    Output should indicate the <code>{{{ service }}}</code> service has either not been installed,
    or has been disabled at all runlevels, as shown in the example below:
    <pre>$ sudo chkconfig <code>{{{ service }}}</code> --list
    <code>{{{ service }}}</code>       0:off   1:off   2:off   3:off   4:off   5:off   6:off</pre>

    Run the following command to verify <code>{{{ service }}}</code> is disabled through current runtime configuration:
    <pre>$ sudo service {{{ service }}} status</pre>

    If the service is disabled the command will return the following output:
    <pre>{{{ service }}} is stopped</pre>
{{%- endmacro %}}


{{#
    Inserts an OCIL for a case when a service should be disabled,
    substituting the correct init system.

:param service: Name of service
:type service: str

#}}
{{% macro ocil_service_disabled(service) -%}}
  {{% if init_system is defined %}}
    {{%- if init_system == "systemd" -%}}
        {{{ systemd_ocil_service_disabled(service) }}}
    {{%- elif init_system == "upstart" -%}}
        {{{ upstart_ocil_service_disabled(service) }}}
    {{%- else -%}}
JINJA MACRO ERROR - Unknown init system '{{{ init_system }}}'.
    {{%- endif -%}}
  {{%- endif -%}}
{{%- endmacro %}}


{{# Socket and Service Disabled macros #}}

{{#
    Describe how to check if service is disabled in system boot configuration with xinetd.

:param service: service to disable
:type service: str

#}}
{{%- macro xinetd_disabled_check_with_systemd(service) %}}
    To check that the <code>{{{ service }}}</code> service is disabled in system boot configuration with xinetd, run the following command:
    <pre>$ chkconfig <code>{{{ service }}}</code> --list</pre>
    Output should indicate the <code>{{{ service }}}</code> service has either not been installed, or has been disabled, as shown in the example below:
    <pre>$ chkconfig <code>{{{ service }}}</code> --list

    Note: This output shows SysV services only and does not include native
    systemd services. SysV configuration data might be overridden by native
    systemd configuration.

    If you want to list systemd services use 'systemctl list-unit-files'.
    To see services enabled on particular target use
    'systemctl list-dependencies [target]'.

    <code>{{{ service }}}</code>       off</pre>
{{%- endmacro %}}


{{#
    Describe how to check if socket is disabled with systemd.

:param socket: The socket to check
:type socket: str

#}}
{{%- macro socket_disabled_check_with_systemd(socket) %}}
    To check that the <code>{{{ socket }}}</code> socket is disabled in system boot configuration with systemd, run the following command:
    <pre>$ systemctl is-enabled <code>{{{ socket }}}</code></pre>
    Output should indicate the <code>{{{ socket }}}</code> socket has either not been installed,
    or has been disabled at all runlevels, as shown in the example below:
    <pre>$ systemctl is-enabled <code>{{{ socket }}}</code><br/>disabled</pre>

    Run the following command to verify <code>{{{ socket }}}</code> is not active (i.e. not running) through current runtime configuration:
    <pre>systemctl is-active {{{ socket }}}</pre>

    If the socket is not running the command will return the following output:
    <pre>inactive</pre>

    The socket will also be masked, to check that the <code>{{{ socket }}}</code> is masked, run the following command:
    <pre>$ systemctl show <code>{{{ socket }}}</code> | grep "LoadState\|UnitFileState"</pre>

    If the socket is masked the command will return the following outputs:

    <pre>LoadState=masked</pre>

    <pre>UnitFileState=masked</pre>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for ensure socket is disabled in systemd and xinetd.

:param name: The socket to check
:type name: str

#}}
{{%- macro systemd_complete_ocil_entry_socket_and_service_disabled(name) %}}
ocil: |-
    {{{ xinetd_disabled_check_with_systemd(name) }}}
    {{{ socket_disabled_check_with_systemd(name) }}}

ocil_clause: "service and/or socket are running"
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for ensure socket is disabled in systemd.

:param name: The socket to check
:type name: str

#}}
{{%- macro upstart_complete_ocil_entry_socket_and_service_disabled(name) %}}
ocil:

ocil_clause: "service and/or socket are running"
{{%- endmacro %}}


{{#
    Inserts an OCIL for a case when a service and a corresponding socket should be
    disabled, substituting the correct init system.

:param service: Name of service
:type service: str

#}}
{{% macro complete_ocil_entry_socket_and_service_disabled(service) -%}}
  {{% if init_system is defined %}}
    {{%- if init_system == "systemd" -%}}
        {{{ systemd_complete_ocil_entry_socket_and_service_disabled(service) }}}
    {{%- elif init_system == "upstart" -%}}
        {{{ upstart_complete_ocil_entry_socket_and_service_disabled(service) }}}
    {{%- else -%}}
ocil: |-
    JINJA MACRO ERROR - Unknown init system '{{{ init_system }}}'.
    {{%- endif -%}}
  {{%- endif -%}}
{{%- endmacro %}}


{{# SSHD macros #}}

{{#
    An OCIL clause for an sshd option
#}}
{{% macro ocil_clause_entry_sshd_option() -%}}
ocil_clause: "the required value is not set"
{{%- endmacro %}}


{{#
    OCIL for an sshd option.

    Example usage::

        ocil_sshd_option(default="no", option="Banner", value="/etc/issue")

:param default: If set to yes the default value is accepted
:type default: str
:param option: The sshd option to configure
:type option: str
:param value: The value for the given option
:type value: str

#}}
{{% macro ocil_sshd_option(default, option, value) -%}}
    To determine how the SSH daemon's <tt>{{{ option }}}</tt> option is set, run the following command:
    {{% if sshd_distributed_config == "true" %}}
    <pre>$ sudo grep -i {{{ option }}} /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</pre>
    {{% else %}}
    <pre>$ sudo grep -i {{{ option }}} /etc/ssh/sshd_config</pre>
    {{% endif %}}
    {{% if default == "yes" -%}}
    If no line, a commented line, or a line indicating the value <tt>{{{ value }}}</tt> is returned, then the required value is set.
    {{%- else %}}
    If a line indicating <tt>{{{ value }}}</tt> is returned, then the required value is set.
    {{%- endif %}}
{{%- endmacro %}}


{{#
OCIL and OCIL clause for and sshd option.

    Example usage::

        complete_ocil_entry_sshd_option(default="no", option="Banner", value="/etc/issue")

:param default: If set to yes the default value is accepted
:type default: str
:param option: The sshd option to configure
:type option: str
:param value: The value for the given option
:type value: str

#}}
{{% macro complete_ocil_entry_sshd_option(default, option, value) -%}}
ocil: |
    {{{ ocil_sshd_option(default, option, value) }}}

{{{ ocil_clause_entry_sshd_option() }}}
{{%- endmacro %}}


{{# Mount option macros #}}

{{#
    The OCIL text for mount options.

:param point: The mount point to check
:type point: str
:param option: The options the mount point should have
:type option: str

#}}
{{% macro ocil_mount_option(point, option) -%}}
    To verify the <tt>{{{ option }}}</tt> option is configured for the <tt>{{{ point }}}</tt> mount point,
    {{% if product == "rhcos4" -%}}
    You'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Subsequently,
    {{%- endif -%}}
    run the following command:
    <pre>$ mount | grep '\s{{{ point }}}\s'</pre>
    The output should show the corresponding mount point along with the <tt>{{{ option }}}</tt> setting in parentheses.
{{%- endmacro %}}


{{#
    The OCIL clause for mount options.

:param point: The mount point to check
:type point: str
:param option: The options the mount point should have
:type option: str

#}}
{{% macro ocil_clause_entry_mount_option(point, option) -%}}
ocil_clause: "the {{{ option }}} is not present in the output line, or there is no output line at all"
{{%- endmacro %}}


{{#
    The OCIL and OCIL clause for mount options.

:param point: The mount point to check
:type point: str
:param option: The options the mount point should have
:type option: str

#}}
{{% macro complete_ocil_entry_mount_option(point, option) -%}}
ocil: |
    {{{ ocil_mount_option(point, option) | indent(4) }}}

{{{ ocil_clause_entry_mount_option() }}}
{{%- endmacro %}}


{{# Partition macros #}}

{{#
    Describe how to check if given path is on its own partition or logical volume.

:param part: Path to check
:type part: str

#}}
{{% macro partition_check(part) -%}}
    {{% if product == "rhcos4" -%}}
    You'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Subsequently,
    {{%- endif -%}}
    Run the following command to determine if <code>{{{ part }}}</code>
    is on its own partition or logical volume:
    <pre>$ mount | grep "on {{{ part }}}"</pre>
    If <code>{{{ part }}}</code> has its own partition or volume group, a line will be returned.
{{%- endmacro %}}


{{#
    OCIL for how to check if given path is on its own partition or logical volume and the
    correct OCIL clause.

:param part: Path to check
:type part: str

#}}
{{% macro complete_ocil_entry_separate_partition(part) -%}}
ocil: |
    {{{ partition_check(part) }}}

ocil_clause: "no line is returned"
{{%- endmacro %}}


{{# Firewalld macros #}}

{{%- macro _firewalld_check(access_action, port, proto, service) %}}
    To determine if <code>firewalld</code> is configured to {{{ access_action }}} to <code>{{{ service }}}</code>
    on port <code>{{{ port }}}/{{{ proto }}}</code>, run the following command(s):
    {{% if port %}}
        <code>firewall-cmd --list-ports</code>
    {{% endif %}}
    {{% if service %}}
        <code>firewall-cmd --list-services</code>
    {{% endif %}}
{{%- endmacro %}}


{{#
    OCIL for allowing a port or service in firewalld. If the :code:`service` parameter is defined
    it is assumed to be a service and the :code:`port` and :code:`proto` parameters will have no effect.

:param port: The port to allow
:type port: int
:param proto: The protocol to allow
:type proto: str
:param service: The service to allow
:type service: str

#}}
{{%- macro ocil_firewalld_allow_access(port, proto, service) %}}
{{{ _firewalld_check("allow access", port, proto, service) }}}
    If <code>firewalld</code> is configured to allow access through the firewall, something similar to the following will be output:
    {{% if service %}}
    If it is a service:
    <code>{{{ service }}}</code>
    {{% endif %}}
    {{% if port %}}
    If it is a port:
    <code>{{{ port }}}/{{{ proto }}}</code>
    {{% endif %}}
{{%- endmacro %}}


{{#
    OCIL for preventing access a port or service in firewalld. If the :code:`service` parameter is defined
    it is assumed to be a service and the :code:`port` and :code:`proto` parameters will have no effect.

:param port: The port to allow
:type port: int
:param proto: The protocol to allow
:type proto: str
:param service: The service to allow
:type service: str

#}}
{{%- macro ocil_firewalld_prevent_access(port, proto, service) %}}
{{{ _firewalld_check("prevent access", port, proto, service) }}}
    If <code>firewalld</code> is configured to prevent access, no output will be returned.
{{%- endmacro %}}

{{# Kernel modules macros #}}

{{#
    OCIL for disabling a kernel module.

:param module: The module to disable.
:type module: str

#}}
{{%- macro ocil_module_disable(module) %}}
    If the system is configured to prevent the loading of the <code>{{{ module }}}</code> kernel module,
    it will contain lines inside any file in <code>/etc/modprobe.d</code> or the deprecated<code>/etc/modprobe.conf</code>.
    These lines instruct the module loading system to run another program (such as <code>/bin/true</code>) upon a module <code>install</code> event.
    Run the following command to search for such lines in all files in <code>/etc/modprobe.d</code> and the deprecated <code>/etc/modprobe.conf</code>:
    <pre>$ grep -r {{{ module }}} /etc/modprobe.conf /etc/modprobe.d</pre>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for disabling a kernel module.

:param module: The module to disable.
:type module: str

#}}
{{%- macro complete_ocil_entry_module_disable(module) %}}
ocil: |-
    {{{ ocil_module_disable(module) }}}

ocil_clause: "no line is returned"
{{%- endmacro %}}


{{# SELinux boolean macros #}}

{{#
    Describe how to check if given SELinux boolean is disabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro describe_sebool_check_disabled(sebool) %}}
    Run the following command to determine if the <code>{{{ sebool }}}</code> SELinux boolean is disabled:
    <pre>$ getsebool {{{ sebool }}}</pre>
    If properly configured, the output should show the following:
    <code>{{{ sebool }}} --> off</code>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for how to check if given SELinux boolean is disabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro complete_ocil_entry_sebool_disabled(sebool) %}}
ocil: |-
    {{{ describe_sebool_check_disabled(sebool) }}}

ocil_clause: "{{{ sebool }}} is not disabled"
{{%- endmacro %}}


{{#
    Describe how to check if given SELinux boolean is enabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro describe_sebool_check_enabled(sebool) %}}
    Run the following command to determine if the <code>{{{ sebool }}}</code> SELinux boolean is enabled:
    <pre>$ getsebool {{{ sebool }}}</pre>
    If properly configured, the output should show the following:
    <code>{{{ sebool }}} --> on</code>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for how to check if given SELinux boolean is enabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro complete_ocil_entry_sebool_enabled(sebool) %}}
ocil: |-
    {{{ describe_sebool_check_enabled(sebool) }}}

ocil_clause: "{{{ sebool }}} is not enabled"
{{%- endmacro %}}
