{{#
Pass strings that correspond to XCCDF value names as arguments to this macro:
ansible_instantiate_variables("varname1", "varname2")

Then, assume that the task that follows can work with the variable by referencing it, e.g.
value: :code:`Setting={{ varname1 }}`

#}}
{{%- macro ansible_instantiate_variables() -%}}
{{%- for name in varargs -%}}
- (xccdf-var {{{ name }}})
{{% endfor -%}}
{{%- endmacro -%}}


{{#
  A wrapper over the Ansible lineinfile module. This handles the most common
  options for us. regex is optional and when blank, it won't be included in
  the Ansible script; this allows arbitrary additions to files. new_line will
  only be passed when state is present. with_items will be specified only if
  non-empty, allowing for iterating through a variable of content (with the
  appropriate macro-based path). register will be specified only if non-empty,
  allowing for saving the output of this lineinfile module. check_mode allows
  an idempotent way to gather output, or run a task without changes. Useful when
  calling the ansible_only_lineinfile macro to handle deduplication of values.

  Note that all string-like parameters are single quoted in the YAML.
#}}
{{%- macro ansible_lineinfile(msg='', path='', regex='', new_line='', create='no', state='present', with_items='', register='', when='', validate='', insert_after='', insert_before='', check_mode=False) -%}}
- name: "{{{ msg or rule_title }}}"
  lineinfile:
    path: '{{{ path }}}'
    create: {{{ create }}}
    {{%- if regex %}}
    regexp: '{{{ regex }}}'
    {{%- endif %}}
    {{%- if state == 'present' %}}
    line: '{{{ new_line }}}'
    state: present
    {{%- if insert_after %}}
    insertafter: '{{{ insert_after }}}'
    {{%- elif insert_before %}}
    insertbefore: '{{{ insert_before }}}'
    {{%- endif %}}
    {{%- else %}}
    state: '{{{ state }}}'
    {{%- endif %}}
    {{%- if validate %}}
    validate: '{{{ validate }}}'
    {{%- endif %}}
  {{%- if with_items %}}
  with_items: '{{{ with_items }}}'
  {{%- endif %}}
  {{%- if check_mode %}}
  check_mode: yes
  changed_when: no
  {{%- endif %}}
  {{%- if register %}}
  register: '{{{ register }}}'
  {{%- endif %}}
  {{%- if when %}}
  when: '{{{ when }}}'
  {{%- endif %}}
{{%- endmacro %}}


{{#
  Check the file system status of an object. Not a full implementation.

:parameter msg: Optional task title
:type msg: str
:parameter path: Path to file
:type path: str
:parameter register: variable to register
:type register: str

#}}
{{%- macro ansible_stat(msg='', path='', register='') %}}
- name: '{{{ msg or rule_title }}}'
  stat:
    path: '{{{ path }}}'
  {{%- if register %}}
  register: '{{{ register }}}'
  {{%- endif %}}
{{%- endmacro %}}


{{#
  Find files matching a particular value. Not a full implementation.
#}}
{{%- macro ansible_find(msg='', paths='', recurse='yes', follow='no', contains='', register='', when='') %}}
- name: '{{{ msg or rule_title }}}'
  find:
    paths: '{{{ paths }}}'
    recurse: '{{{ recurse }}}'
    follow: '{{{ follow }}}'
    {{%- if contains %}}
    contains: '{{{ contains }}}'
    {{%- endif %}}
  {{%- if register %}}
  register: '{{{ register }}}'
  {{%- endif %}}
  {{%- if when %}}
  when: '{{{ when }}}'
  {{%- endif %}}
{{%- endmacro %}}


{{#
  A wrapper for adding one, unique line to a file. A regex must be specified
  to tell if the line is unique. This is helpful in configuration files where
  a single configuration parameter might have multiple values, but only one
  value is approved. All lines matching the regex are first removed and then
  the new line is appended to the file.
#}}
{{%- macro ansible_only_lineinfile(msg, path, line_regex, new_line, create='no', block=False, validate='', insert_after='', insert_before='') -%}}
{{%- if block %}}
- name: "{{{ msg or rule_title }}}"
  block:
    {{{ ansible_lineinfile("Check for duplicate values", path, regex=line_regex, create='no', state='absent', register='dupes', check_mode=True)|indent }}}
    {{{ ansible_lineinfile("Deduplicate values from " + path, path, regex=line_regex, create='no', state='absent', when='dupes.found is defined and dupes.found > 1')|indent }}}
    {{{ ansible_lineinfile("Insert correct line to " + path, path, regex=line_regex, new_line=new_line, create=create, state='present', validate=validate, insert_after=insert_after, insert_before=insert_before)|indent }}}
{{%- else %}}
{{{ ansible_lineinfile("Check for duplicate values", path, regex=line_regex, create='no', state='absent', register='dupes', check_mode=True) }}}
{{{ ansible_lineinfile("Deduplicate values from " + path, path, regex=line_regex, create='no', state='absent', when='dupes.found is defined and dupes.found > 1') }}}
{{{ ansible_lineinfile("Insert correct line into " + path, path, regex=line_regex, new_line=new_line, create=create, state='present', validate=validate, insert_after=insert_after, insert_before=insert_before) }}}
{{%- endif %}}
{{%- endmacro %}}


{{#
  Ensure the configuration is set in a file. Note this handles generic
  key-seperator-value files with no sense of structure. In particular,
  ini configuration files are best served with the ini Ansible module
  instead of lineinfile-based solutions.
#}}
{{%- macro ansible_set_config_file(msg, file, parameter, separator=' ', separator_regex='\s+', value='', prefix_regex='^\s*', create='no', validate='', insert_after='', insert_before='', escape_regex=False) %}}
{{{ ansible_only_lineinfile(msg, file, prefix_regex + parameter + separator_regex, parameter + separator + value, create=create, block=True, validate=validate, insert_after=insert_after, insert_before=insert_before) }}}
{{%- endmacro %}}


{{#
  Ensure the configuration is set in a file and not conflicted by a
  configuration in a directory. Note this handles generic key-separator-value
  files with no sense of structure. In particular, ini configuration files are
  best served with the ini Ansible module instead of lineinfile-based
  solutions.
#}}
{{%- macro ansible_set_config_file_dir(msg, config_file, config_dir, set_file, parameter, separator=' ', separator_regex='\s+', value='', prefix_regex='^\s*', create='no', validate='', insert_after='', insert_before='') %}}
{{%- set var_dir = config_dir | replace("/", "_") | replace("-", "_") | replace(".", "_") -%}}
{{%- set dir_exists = var_dir + "_exists" -%}}
{{%- set dir_parameter = var_dir + "_has_parameter" -%}}
{{%- set line_regex = prefix_regex + "{{ \"" + parameter + "\"| regex_escape }}" + separator_regex -%}}
{{%- set find_when = dir_exists + ".stat.isdir is defined and " + dir_exists + ".stat.isdir" -%}}
{{%- set lineinfile_items = "{{ " + dir_parameter + ".files }}" -%}}
{{%- set lineinfile_when = dir_parameter + ".matched" -%}}
{{%- set new_line = parameter + separator + value -%}}
- name: '{{{ msg or rule_title }}}'
  block:
    {{{ ansible_lineinfile("Deduplicate values from " + config_file, config_file, regex=line_regex, create='no', state='absent')|indent }}}
    {{{ ansible_stat("Check if " + config_dir + " exists", path=config_dir, register=dir_exists)|indent }}}
    {{{ ansible_find("Check if the parameter " + parameter + " is present in " + config_dir, paths=config_dir, contains=line_regex, register=dir_parameter, when=find_when)|indent }}}
    {{{ ansible_lineinfile("Remove parameter from files in " + config_dir, path="{{ item.path }}", regex=line_regex, state="absent", with_items=lineinfile_items, when=lineinfile_when)|indent }}}
    {{{ ansible_lineinfile("Insert correct line to " + set_file, set_file, regex=line_regex, new_line=new_line, create=create, state='present', validate=validate, insert_after=insert_after, insert_before=insert_before)|indent }}}
{{%- endmacro %}}


{{#
  High level macro to set a value in the ssh daemon configuration file. This
  takes three values: msg (the name for the Ansible task), a parameter to set
  in the configuration file, and the value to set it to. We specify a case
  insensitive comparison in the prefix since this is used to deduplicate since
  sshd_config has case-insensitive parameters (but case-sensitive values).
  We also specify the validation program here; -t specifies test and -f allows
  Ansible to pass a file at a different path.
#}}
{{%- macro ansible_sshd_set(msg='', parameter='', value='', config_is_distributed="false") %}}
{{%- if config_is_distributed == "true" %}}
{{{ ansible_set_config_file_dir(msg, config_file="/etc/ssh/sshd_config", config_dir="/etc/ssh/sshd_config.d", set_file="/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf", parameter=parameter, separator_regex="\s+", value=value, prefix_regex="^\s*", create='yes', validate='/usr/sbin/sshd -t -f %s', insert_after='', insert_before="^[#\s]*Match") }}}
{{%- else %}}
{{{ ansible_set_config_file(msg, "/etc/ssh/sshd_config", parameter, value=value, create="yes", prefix_regex='(?i)^\s*', validate="/usr/sbin/sshd -t -f %s", insert_before="^[#\s]*Match") }}}
{{%- endif %}}
{{%- endmacro %}}


{{#
  High level macro to set a value in a shell-related file that contains var assignments.

  We also specify the validation program here; see

    bash -c "help set" | grep -e -n

:param msg: The name for the Ansible task
:type msg: str
:param path: to the file
:type path: str
:param parameter: Parameter to be set in the configuration file
:type parameter: str
:param value: value of the parameter
:type value: str

#}}
{{%- macro ansible_shell_set(msg, path, parameter, value='', no_quotes=false) %}}
{{% if no_quotes -%}}
{{%- else -%}}
{{# Use the double quotes in all cases, as the underlying macro single-quotes the assignment line. #}}
{{% set value = '"%s"' % value %}}
{{%- endif -%}}
{{{ ansible_set_config_file(msg, path, parameter, separator="=", separator_regex="=", value=value, create="yes", prefix_regex='^\s*', validate="/usr/bin/bash -n %s", insert_before="^# " ~ parameter) }}}
{{%- endmacro %}}


{{#
  High level macro to set a command in tmux configuration file /etc/tmux.conf.
  Automatically adds "set -g " before the parameter.
:param msg: The name for the Ansible task
:type msg: str
:param parameter: Parameter to be set in the configuration file
:type parameter: str
:param value: Value of the parameter
:type value: str

#}}
{{%- macro ansible_tmux_set(msg='', parameter='', value='') %}}
{{{ ansible_set_config_file(msg, "/etc/tmux.conf", "set -g " + parameter, value=value, create="yes") }}}
{{%- endmacro %}}


{{#
  High level macro to set a value in /etc/profile (and /etc/profile.d) bash
  files. Note this is only suitable for calling a single command once with the
  correct arguments and not for calling the same command multiple times with
  different arguments. This includes setting an environment variable once.
#}}
{{%- macro ansible_etc_profile_set(msg='', parameter='', value='') %}}
{{{ ansible_set_config_file_dir(msg, "/etc/profile", "/etc/profile.d", "/etc/profile", parameter, separator='=', separator_regex='=', value=value, create='yes', validate="bash -n %s") }}}
{{%- endmacro %}}


{{#
  High level macro to set a command in auditd configuration file /etc/audit/auditd.conf.

:param msg: The name for the Ansible task
:type msg: str
:param parameter: Parameter to be set in the configuration file
:type parameter: str
:param value: Value of the parameter
:type value: str

#}}
{{%- macro ansible_auditd_set(msg='', parameter='', value='') %}}
{{{ ansible_set_config_file(msg, "/etc/audit/auditd.conf", parameter=parameter, value=value, create="yes", prefix_regex='(?i)^\s*', separator=" = ", separator_regex="\s*=\s*") }}}
{{%- endmacro %}}


{{#
  High level macro to set a parameter in /etc/systemd/coredump.conf.

:param msg: The name for the Ansible task
:type msg: str
:param parameter: Parameter to be set in the configuration file
:type parameter: str
:param value: Value of the parameter
:type value: str

#}}
{{%- macro ansible_coredump_config_set(msg='', parameter='', value='') %}}
{{{ ansible_set_config_file(msg, "/etc/systemd/coredump.conf", parameter=parameter, value=value, create="no", separator="=", separator_regex="\s*=\s*") }}}
{{%- endmacro %}}


{{#
  High level macro to set a parameter in /etc/selinux/config.

:param msg: The name for the Ansible task
:type msg: str
:param parameter: Parameter to be set in the configuration file
:type parameter: str
:param value: Value of the parameter
:type value: str

#}}
{{%- macro ansible_selinux_config_set(msg='', parameter='', value='') %}}
{{{ ansible_set_config_file(msg, "/etc/selinux/config", parameter=parameter, value=value, create="yes", separator="=", separator_regex="=", prefix_regex='^') }}}
{{%- endmacro %}}


{{#
  Generates an Ansible task that puts 'contents' into a file at 'filepath'

:param filepath: filepath of the file to check
:type filepath: str
:param contents: contents that should be in the file
:type contents: str
#}}
{{%- macro ansible_file_contents(filepath='', contents='') %}}
- name: "Put contents into {{{ filepath }}} according to policy"
  copy:
    dest: "{{{ filepath }}}"
    content: |+
        {{{ contents|indent(8) }}}
    force: yes
{{%- endmacro %}}


{{#
  Formats a banner regex for use in :code:`/etc/issue`

:param banner_var_name: name of ansible variable with the banner regex
:type banner_var_name: str
#}}
{{% macro ansible_deregexify_banner_etc_issue(banner_var_name) -%}}
{{ {{{ banner_var_name }}} |
{{{ ansible_deregexify_banner_anchors() }}} |
{{{ ansible_deregexify_multiple_banners() }}} |
{{{ ansible_deregexify_banner_space() }}} |
{{{ ansible_deregexify_banner_newline("\\n") }}} |
{{{ ansible_deregexify_banner_backslash() }}} |
wordwrap() }}
{{%- endmacro %}}


{{#
  Formats a banner regex for use in dconf

:param banner_var_name: name of ansible variable with the banner regex
:type banner_var_name: str
#}}
{{% macro ansible_deregexify_banner_dconf_gnome(banner_var_name) -%}}
''{{ {{{ banner_var_name }}} |
{{{ ansible_deregexify_banner_anchors() }}} |
{{{ ansible_deregexify_multiple_banners() }}} |
{{{ ansible_deregexify_banner_space() }}} |
{{{ ansible_deregexify_banner_newline("(n)*") }}} |
{{{ ansible_deregexify_banner_backslash() }}} |
{{{ ansible_deregexify_banner_newline_token()}}} }}''
{{%- endmacro %}}


{{# Strips anchors around the banner #}}
{{% macro ansible_deregexify_banner_anchors() -%}}
regex_replace("^\^(.*)\$$", "\1")
{{%- endmacro %}}


{{# Strips multibanner regex and keeps only the first banner #}}
{{% macro ansible_deregexify_multiple_banners() -%}}
regex_replace("^\((.*\.)\|.*\)$", "\1")
{{%- endmacro %}}


{{# Strips whitespace or newline regex #}}
{{% macro ansible_deregexify_banner_space() -%}}
regex_replace("\[\\s\\n\]\+"," ")
{{%- endmacro %}}


{{# Strips newline or newline escape sequence regex #}}
{{% macro ansible_deregexify_banner_newline(newline) -%}}
regex_replace("\(\?:\[\\n\]\+\|\(\?:\\\\n\)\+\)", "{{{ newline }}}")
{{%- endmacro %}}


{{# Strips newline token for a newline escape sequence regex #}}
{{% macro ansible_deregexify_banner_newline_token() -%}}
regex_replace("\(n\)\*", "\\n")
{{%- endmacro %}}


{{# Strips backslash regex #}}
{{% macro ansible_deregexify_banner_backslash() -%}}
regex_replace("\\", "")
{{%- endmacro %}}


{{#
The following macro remediates one audit watch rule in :code:`/etc/audit/rules.d` directory.

:param path: path to watch
:type path: str
:param permissions: permissions changes to watch for
:type permissions: str
:param key: key to use as identifier. Note that if there exists any other rule with the same find_mac_key in some file within :code:`/etc/audit/rules.d/`, the new rule will be appended to this file.
:type key: str

#}}
{{% macro ansible_audit_augenrules_add_watch_rule(path='', permissions='', key='') -%}}
- name: Check if watch rule for {{{ path }}} already exists in /etc/audit/rules.d/
  find:
    paths: "/etc/audit/rules.d"
    contains: '^\s*-w\s+{{{ path }}}\s+-p\s+{{{ permissions }}}(\s|$)+'
    patterns: "*.rules"
  register: find_existing_watch_rules_d

- name: Search /etc/audit/rules.d for other rules with specified key {{{ key }}}
  find:
    paths: "/etc/audit/rules.d"
    contains: '^.*(?:-F key=|-k\s+){{{ key }}}$'
    patterns: "*.rules"
  register: find_watch_key
  when: find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

- name: Use /etc/audit/rules.d/{{{ key }}}.rules as the recipient for the rule
  set_fact:
    all_files:
      - /etc/audit/rules.d/{{{ key }}}.rules
  when: find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

- name: Use matched file as the recipient for the rule
  set_fact:
    all_files:
      - "{{ find_watch_key.files | map(attribute='path') | list | first }}"
  when: find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

- name: Add watch rule for {{{ path }}} in /etc/audit/rules.d/
  lineinfile:
    path: "{{ all_files[0] }}"
    line: "-w {{{ path }}} -p {{{ permissions }}} -k {{{ key }}}"
    create: yes
    mode: '0640'
  when: find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0
{{%- endmacro %}}


{{#
The following macro remediates one audit watch rule in :code:`/etc/audit/audit.rules`.

:param path: Path to watch
:type path: str
:param permissions: Permissions changes to watch for
:type permissions: str
:param key: Key to use as identifier
:type key: str

#}}
{{% macro ansible_audit_auditctl_add_watch_rule(path='', permissions='', key='') -%}}
- name: Check if watch rule for {{{ path }}} already exists in /etc/audit/audit.rules
  find:
    paths: "/etc/audit/"
    contains: '^\s*-w\s+{{{ path }}}\s+-p\s+{{{ permissions }}}(\s|$)+'
    patterns: "audit.rules"
  register: find_existing_watch_audit_rules

- name: Add watch rule for {{{ path }}} in /etc/audit/audit.rules
  lineinfile:
    line: "-w {{{ path }}} -p {{{ permissions }}} -k {{{ key }}}"
    state: present
    dest: /etc/audit/audit.rules
    create: yes
    mode: '0640'
  when: find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0
{{%- endmacro %}}


{{#
The following macro remediates Audit syscall rule in :code:`/etc/audit/rules.d` directory.
The macro requires following parameters:

:param action_arch_filters: The action and arch filters of the rule. For example, "-a always,exit -F arch=b64"
:param other_filters: Other filters that may characterize the rule. For example, "-F a2&03 -F path=/etc/passwd"
:param auid_filters: The auid filters of the rule. For example, "-F auid>=1000 -F auid!=unset"
:param syscalls: List of syscalls to ensure presense among audit rules. For example, "['fchown', 'lchown', 'fchownat']"
:param syscall_groupings: List of other syscalls that can be grouped with 'syscalls'. For example, "['fchown', 'lchown', 'fchownat']"
:param key: The key to use when appending a new rule

#}}
{{% macro ansible_audit_augenrules_add_syscall_rule(action_arch_filters="", other_filters="", auid_filters="", syscalls=[], key="", syscall_grouping=[]) -%}}
{{% if other_filters != "" %}}
    {{% set other_filters = " " ~ other_filters %}}
{{% endif %}}
{{% if auid_filters != "" %}}
    {{% set auid_filters = " " ~ auid_filters %}}
{{% endif %}}
{{% if syscalls == [] %}}
    {{% set syscall_flag = "" %}}
{{% else %}}
    {{% set syscall_flag = " -S " %}}
{{% endif %}}
- name: Declare list of syscalls
  set_fact:
    syscalls: {{{ syscalls }}}
    syscall_grouping: {{{ syscall_grouping }}}

- name: Check existence of {{{ syscalls | join(", ") }}} in /etc/audit/rules.d/
  find:
    paths: /etc/audit/rules.d
    contains: '{{{ action_arch_filters }}}(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*{{{ other_filters }}}{{{ auid_filters }}} (-k\s+|-F\s+key=)\S+\s*$'
    patterns: '*.rules'
  register: find_command
  loop: '{{ (syscall_grouping + syscalls) | unique }}'

- name: Reset syscalls found per file
  set_fact:
    syscalls_per_file: {}
    found_paths_dict: {}

- name: Declare syscalls found per file
  set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
  loop: "{{ find_command.results | selectattr('matched') | list }}"

- name: Declare files where syscalls were found
  set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

- name: Count occurrences of syscalls in paths
  set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
  loop: "{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

- name: Get path with most syscalls
  set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
  when: found_paths | length >= 1

- name: No file with syscall found, set path to /etc/audit/rules.d/{{{ key }}}.rules
  set_fact: audit_file="/etc/audit/rules.d/{{{ key }}}.rules"
  when: found_paths | length == 0

- name: Declare found syscalls
  set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

- name: Declare missing syscalls
  set_fact:
    missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

- name: Replace the audit rule in {{ audit_file }}
  lineinfile:
    path: '{{ audit_file }}'
    regexp: '({{{ action_arch_filters }}})(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)({{{ other_filters }}}{{{ auid_filters }}} (?:-k |-F key=)\w+)'
    line: '\1\2\3{{ missing_syscalls | join("\3") }}\4'
    backrefs: yes
    state: present
  when: syscalls_found | length > 0 and missing_syscalls | length > 0

- name: Add the audit rule to {{ audit_file }}
  lineinfile:
    path: '{{ audit_file }}'
    line: "{{{ action_arch_filters }}}{{{ syscall_flag }}}{{ syscalls | join(',') }}{{{ other_filters }}}{{{ auid_filters}}} -F key={{{ key }}}"
    create: true
    mode: o-rwx
    state: present
  when: syscalls_found | length == 0
{{%- endmacro %}}


{{#
The following macro remediates Audit syscall rule in :code:`/etc/audit/audit.rules` file.

:param action_arch_filters:  The action and arch filters of the rule. For example, "-a always,exit -F arch=b64"
:param other_filters:        Other filters that may characterize the rule. For example, "-F a2&03 -F path=/etc/passwd"
:param auid_filters: The auid filters of the rule. For example, "-F auid>=1000 -F auid!=unset"
:param syscalls: List of syscalls to ensure presense among audit rules. For example, "['fchown', 'lchown', 'fchownat']"
:param syscall_groupings: List of other syscalls that can be grouped with 'syscalls'
                        For example, "['fchown', 'lchown', 'fchownat']"
:param key: The key to use when appending a new rule

#}}
{{% macro ansible_audit_auditctl_add_syscall_rule(action_arch_filters="", other_filters="", auid_filters="", syscalls=[], key="", syscall_grouping=[]) -%}}
{{% if other_filters!= "" %}}
    {{% set other_filters = " " ~ other_filters %}}
{{% endif %}}
{{% if auid_filters!= "" %}}
    {{% set auid_filters = " " ~ auid_filters %}}
{{% endif %}}
{{% if syscalls == [] %}}
    {{% set syscall_flag = "" %}}
{{% else %}}
    {{% set syscall_flag = " -S " %}}
{{% endif %}}
- name: Declare list of syscalls
  set_fact:
    syscalls: {{{ syscalls }}}
    syscall_grouping: {{{ syscall_grouping }}}

- name: Check existence of {{{ syscalls | join(", ") }}} in /etc/audit/audit.rules
  find:
    paths: /etc/audit
    contains: '{{{ action_arch_filters }}}(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)*{{{ other_filters }}}{{{ auid_filters }}} (-k\s+|-F\s+key=)\S+\s*$'
    patterns: 'audit.rules'
  register: find_command
  loop: '{{ (syscall_grouping + syscalls) | unique }}'

- name: Set path to /etc/audit/audit.rules
  set_fact: audit_file="/etc/audit/audit.rules"

- name: Declare found syscalls
  set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

- name: Declare missing syscalls
  set_fact:
    missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

- name: Replace the audit rule in {{ audit_file }}
  lineinfile:
    path: '{{ audit_file }}'
    regexp: '({{{ action_arch_filters }}})(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)({{{ other_filters }}}{{{ auid_filters }}} (?:-k |-F key=)\w+)'
    line: '\1\2\3{{ missing_syscalls | join("\3") }}\4'
    backrefs: yes
    state: present
  when: syscalls_found | length > 0 and missing_syscalls | length > 0

- name: Add the audit rule to {{ audit_file }}
  lineinfile:
    path: '{{ audit_file }}'
    line: "{{{ action_arch_filters }}}{{{ syscall_flag }}}{{ syscalls | join(',') }}{{{ other_filters }}}{{{ auid_filters}}} -F key={{{ key }}}"
    create: true
    mode: o-rwx
    state: present
  when: syscalls_found | length == 0
{{%- endmacro %}}

{{% macro ansible_sssd_ldap_config(parameter, value) -%}}
- name: "Test for id_provider different than Active Directory (ad)"
  command: grep -qzosP '[[:space:]]*\[domain\/[^]]*]([^(\n)]*(\n)+)+?[[:space:]]*id_provider[[:space:]]*=[[:space:]]*((?i)ad)[[:space:]]*$' /etc/sssd/sssd.conf
  register: test_id_provider
  ignore_errors: yes
  changed_when: False
  check_mode: no

- name: "Test for domain group"
  command: grep '\s*\[domain\/[^]]*]' /etc/sssd/sssd.conf
  register: test_grep_domain
  ignore_errors: yes
  changed_when: False
  check_mode: no

- name: "Add default domain group and set {{{ parameter }}} in sssd configuration (if no domain there)"
  ini_file:
    path: /etc/sssd/sssd.conf
    section: "{{ item.section }}"
    option: "{{ item.option }}"
    value: "{{ item.value }}"
  with_items:
    - { section: sssd, option: domains, value: default}
    - { section: domain/default, option: {{{ parameter }}}, value: "{{{ value }}}"}
  when:
    - test_grep_domain.stdout is defined
    - test_grep_domain.stdout | length < 1
    - test_id_provider.stdout is defined
    - test_id_provider.stdout | length < 1

- name: "Set {{{ parameter }}} in sssd configuration"
  ini_file:
    path: /etc/sssd/sssd.conf
    section: "{{ test_grep_domain.stdout | regex_replace('\\[(.*)\\]','\\1') }}"
    option: {{{ parameter }}}
    value: "{{{ value }}}"
  when:
    - test_grep_domain.stdout is defined
    - test_grep_domain.stdout | length > 0
    - test_id_provider.stdout is defined
    - test_id_provider.stdout | length < 1
{{%- endmacro %}}


{{% macro ansible_ini_file_set(filename, section, key, value, description="") -%}}
- name: "{{{ description if description else ("Set '" + key + "' to '" + value + "' in the [" + section + "] section of '" + filename + "'") }}}"
  ini_file:
    path: "{{{ filename }}}"
    section: "{{{ section }}}"
    option: "{{{ key }}}"
    value: "{{{ value }}}"
    create: yes
    mode: 0644
{{%- endmacro %}}

{{%- macro ansible_sudo_remove_config(parameter, pattern) -%}}

- name: Find /etc/sudoers.d/ files
  find:
    paths:
      - /etc/sudoers.d/
  register: sudoers

- name: "Remove lines containing {{{ parameter }}} from sudoers files"
  replace:
    regexp: '(^(?!#).*[\s]+{{{ pattern }}}.*$)'
    replace: '# \g<1>'
    path: "{{ item.path }}"
    validate: /usr/sbin/visudo -cf %s
  with_items:
    - { path: /etc/sudoers }
    - "{{ sudoers.files }}"
{{%- endmacro -%}}

{{#
  This macro creates an Ansible snipped which is used in `when` clause to determine applicability of a task.
  If the package passed as a parameter is installed, the task is applicable.
  The macro respects `platform_package_overrides` variable.
#}}
{{%- macro ansible_pkg_conditional(package) -%}}
{{%- if package in platform_package_overrides -%}}
  {{%- set package = platform_package_overrides[package] -%}}
{{%- endif -%}}
'"{{{ package }}}" in ansible_facts.packages'
{{%- endmacro -%}}

{{#
  This macro ensures the pam_faillock.so PAM module is enabled.
  It is enabled using the authselect tool or editing the PAM files, only if authselect tool is not available.
#}}
{{%- macro ansible_pam_faillock_enable() -%}}

- name: {{{ rule_title }}} - Check if system relies on authselect tool
  ansible.builtin.stat:
    path: /usr/bin/authselect
  register: result_authselect_present

- name: {{{ rule_title }}} - Remediation where authselect tool is present
  block:
    - name: {{{ rule_title }}} - Check integrity of authselect current profile
      ansible.builtin.command:
        cmd: authselect check
      register: result_authselect_check_cmd
      changed_when: false
      ignore_errors: yes

    - name: {{{ rule_title }}} - Informative message based on the authselect integrity check result
      ansible.builtin.assert:
        that:
          - result_authselect_check_cmd is success
        fail_msg:
        - authselect integrity check failed. Remediation aborted!
        - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
        - It is not recommended to manually edit the PAM files when authselect tool is available.
        - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
        success_msg:
        - authselect integrity check passed

    - name: {{{ rule_title }}} - Get authselect current features
      ansible.builtin.shell:
        cmd: authselect current | tail -n+3 | awk '{ print $2 }'
      register: result_authselect_features
      changed_when: false
      when:
        - result_authselect_check_cmd is success

    - name: {{{ rule_title }}} - Ensure with-faillock feature is enabled using authselect tool
      ansible.builtin.command:
        cmd: authselect enable-feature with-faillock
      register: result_authselect_cmd
      when:
        - result_authselect_check_cmd is success
        - result_authselect_features.stdout is not search("with-faillock")
  when:
    - result_authselect_present.stat.exists

- name: {{{ rule_title }}} - Remediation where authselect tool is not present
  block:
    - name: {{{ rule_title }}} - Check if pam_faillock.so is already enabled
      ansible.builtin.lineinfile:
        path: /etc/pam.d/system-auth
        regexp: .*auth.*pam_faillock.so (preauth|authfail)
        state: absent
      check_mode: yes
      changed_when: false
      register: result_pam_faillock_is_enabled

    - name: {{{ rule_title }}} - Enable pam_faillock.so preauth editing PAM files
      ansible.builtin.lineinfile:
        path: '{{ item }}'
        line: auth        required      pam_faillock.so preauth
        insertbefore: ^auth.*sufficient.*pam_unix.so.*
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_is_enabled.found == 0

    - name: {{{ rule_title }}} - Enable pam_faillock.so authfail editing PAM files
      ansible.builtin.lineinfile:
        path: '{{ item }}'
        line: auth        required      pam_faillock.so authfail
        insertafter: ^auth.*sufficient.*pam_unix.so.*
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_is_enabled.found == 0

    - name: {{{ rule_title }}} - Enable pam_faillock.so account section editing PAM files
      ansible.builtin.lineinfile:
        path: '{{ item }}'
        line: account     required      pam_faillock.so
        insertbefore: ^account.*required.*pam_unix.so.*
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_is_enabled.found == 0
  when:
    - not result_authselect_present.stat.exists
{{%- endmacro -%}}

{{#
  This macro make sure the informed parameter from pam_faillock.so PAM module is properly set.

  :param parameter:         The pam_faillock.so parameter name.
  :param faillock_var_name: If the parameter expects a value from a variable, the variable name is informed here.
#}}
{{%- macro ansible_pam_faillock_parameter_value(parameter, faillock_var_name='') -%}}

{{%- if faillock_var_name != '' %}}
{{{ ansible_instantiate_variables( faillock_var_name ) }}}
{{%- endif %}}

- name: {{{ rule_title }}} - Check the presence of /etc/security/faillock.conf file
  ansible.builtin.stat:
    path: /etc/security/faillock.conf
  register: result_faillock_conf_check

- name: {{{ rule_title }}} - Ensure the pam_faillock.so {{{ parameter }}} parameter in /etc/security/faillock.conf
  ansible.builtin.lineinfile:
    path: /etc/security/faillock.conf
    {{%- if faillock_var_name == '' %}}
    regexp: ^\s*{{{ parameter }}}
    line: {{{ parameter }}}
    {{%- else %}}
    regexp: ^\s*{{{ parameter }}}\s*=
    line: {{{ parameter }}} = {{ {{{ faillock_var_name }}} }}
    {{%- endif %}}
    state: present
  when:
    - result_faillock_conf_check.stat.exists

- name: {{{ rule_title }}} - Ensure the pam_faillock.so {{{ parameter }}} parameter in PAM files
  block:
    - name: {{{ rule_title }}} - Check if pam_faillock.so {{{ parameter }}} parameter is already enabled in pam files
      ansible.builtin.lineinfile:
        path: /etc/pam.d/system-auth
        regexp: .*auth.*pam_faillock.so (preauth|authfail).*{{{ parameter }}}
        state: absent
      check_mode: yes
      changed_when: false
      register: result_pam_faillock_{{{ parameter }}}_parameter_is_present

    - name: {{{ rule_title }}} - Ensure the inclusion of pam_faillock.so preauth {{{ parameter }}} parameter in auth section
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        backrefs: true
        regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)
        {{%- if faillock_var_name == '' %}}
        line: \1required\3 {{{ parameter }}}
        {{%- else %}}
        line: \1required\3 {{{ parameter }}}={{ {{{ faillock_var_name }}} }}
        {{%- endif %}}
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_{{{ parameter }}}_parameter_is_present.found == 0

    - name: {{{ rule_title }}} - Ensure the inclusion of pam_faillock.so authfail {{{ parameter }}} parameter in auth section
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        backrefs: true
        regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)
        {{%- if faillock_var_name == '' %}}
        line: \1required\3 {{{ parameter }}}
        {{%- else %}}
        line: \1required\3 {{{ parameter }}}={{ {{{ faillock_var_name }}} }}
        {{%- endif %}}
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_{{{ parameter }}}_parameter_is_present.found == 0

    {{%- if faillock_var_name != '' %}}
    - name: {{{ rule_title }}} - Ensure the desired value for pam_faillock.so preauth {{{ parameter }}} parameter in auth section
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        backrefs: true
        regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)({{{ parameter }}})=[0-9]+(.*)
        line: \1required\3\4={{ {{{ faillock_var_name }}} }}\5
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_{{{ parameter }}}_parameter_is_present.found > 0

    - name: {{{ rule_title }}} - Ensure the desired value for pam_faillock.so authfail {{{ parameter }}} parameter in auth section
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        backrefs: true
        regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)({{{ parameter }}})=[0-9]+(.*)
        line: \1required\3\4={{ {{{ faillock_var_name }}} }}\5
        state: present
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - result_pam_faillock_{{{ parameter }}}_parameter_is_present.found > 0
    {{%- endif %}}
  when:
    - not result_faillock_conf_check.stat.exists
{{%- endmacro -%}}
