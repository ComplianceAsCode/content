# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = high
- (xccdf-var {{{ MOUNTPOINT }}})

- name: get back device associated to mountpoint
  shell: |
    set -o pipefail
    mount | grep ' {{ {{{ MOUNTPOINT }}} }} ' |cut -d ' ' -f 1
  args:
    warn: False # Ignore ANSIBLE0006, we can't fetch device name with mount module
    executable: /bin/bash
  register: device_name
  check_mode: no
  changed_when: False

- block:
  - name: get back device previous mount option
    shell: |
      set -o pipefail
      mount | grep ' {{ {{{ MOUNTPOINT }}} }} ' | sed -re 's:.*\((.*)\):\1:'
    args:
      warn: False # Ignore ANSIBLE0006, we can't fetch mount options with mount module
      executable: /bin/bash
    register: device_cur_mountoption
    check_mode: no
    changed_when: False

  - name: get back device fstype
    shell: |
      set -o pipefail
      mount | grep ' {{ {{{ MOUNTPOINT }}} }} ' | cut -d ' ' -f 5
    args:
      warn: False # Ignore ANSIBLE0006, we can't fetch fstype with mount module
      executable: /bin/bash
    register: device_fstype
    check_mode: no
    changed_when: False

  - name: Ensure permission {{{ MOUNTOPTION }}} are set on {{{ MOUNTPOINT }}}
    mount:
      path: "{{ {{{ MOUNTPOINT }}} }}"
      src: "{{ device_name.stdout }}"
      opts: "{{ device_cur_mountoption.stdout }},{{{ MOUNTOPTION }}}"
      state: "mounted"
      fstype: "{{ device_fstype.stdout }}"
  when: (device_name.stdout | length > 0)
