#!/bin/bash

# Created by argbash-init v2.8.1
# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_SINGLE([oval],[o],[OVAL version],[auto])
# ARG_OPTIONAL_SINGLE([builder],[b],[Builder engine],[auto])
# ARG_OPTIONAL_SINGLE([jobs],[j],[Count of simultaneous jobs],[auto])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Make a debug build with draft profiles],[off])
# ARG_OPTIONAL_BOOLEAN([derivatives],[],[Also build derivatives of products if applicable],[off])
# ARG_USE_ENV([ADDITIONAL_CMAKE_OPTIONS],[],[Whitespace-separated string of arguments to pass to CMake])
# ARG_POSITIONAL_INF([product],[Products to build],[1])
# ARG_DEFAULTS_POS([])
# ARG_TYPE_GROUP_SET([oval_ver],[VERSION],[oval],[5.10,5.11,auto])
# ARG_TYPE_GROUP_SET([builder_type],[BUILDER],[builder],[make,ninja,auto])
# ARG_HELP([Wipes out contents of the 'build' directory and builds only and only the given products.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# Setting environmental variables


die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

# validators

oval_ver()
{
	local _allowed=("5.10" "5.11" "auto") _seeking="$1"
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && echo "$element" && return 0
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: '5.10', '5.11' and 'auto'" 4
}


builder_type()
{
	local _allowed=("make" "ninja" "auto") _seeking="$1"
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && echo "$element" && return 0
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: 'make', 'ninja' and 'auto'" 4
}


begins_with_short_option()
{
	local first_option all_short_options='objh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_product=('' )
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_oval="auto"
_arg_builder="auto"
_arg_jobs="auto"
_arg_debug="off"
_arg_derivatives="off"


print_help()
{
	printf '%s\n' "Wipes out contents of the 'build' directory and builds only and only the given products."
	printf 'Usage: %s [-o|--oval <VERSION>] [-b|--builder <BUILDER>] [-j|--jobs <arg>] [--(no-)debug] [--(no-)derivatives] [-h|--help] <product-1> [<product-2>] ... [<product-n>] ...\n' "$0"
	printf '\t%s\n' "<product>: Products to build"
	printf '\t%s\n' "-o, --oval: OVAL version. Can be one of: '5.10', '5.11' and 'auto' (default: 'auto')"
	printf '\t%s\n' "-b, --builder: Builder engine. Can be one of: 'make', 'ninja' and 'auto' (default: 'auto')"
	printf '\t%s\n' "-j, --jobs: Count of simultaneous jobs (default: 'auto')"
	printf '\t%s\n' "--debug, --no-debug: Make a debug build with draft profiles (off by default)"
	printf '\t%s\n' "--derivatives, --no-derivatives: Also build derivatives of products if applicable (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\nEnvironment variables that are supported:\n'
	printf '\t%s\n' "ADDITIONAL_CMAKE_OPTIONS: Whitespace-separated string of arguments to pass to CMake."

}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-o|--oval)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_oval="$(oval_ver "$2" "oval")" || exit 1
				shift
				;;
			--oval=*)
				_arg_oval="$(oval_ver "${_key##--oval=}" "oval")" || exit 1
				;;
			-o*)
				_arg_oval="$(oval_ver "${_key##-o}" "oval")" || exit 1
				;;
			-b|--builder)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_builder="$(builder_type "$2" "builder")" || exit 1
				shift
				;;
			--builder=*)
				_arg_builder="$(builder_type "${_key##--builder=}" "builder")" || exit 1
				;;
			-b*)
				_arg_builder="$(builder_type "${_key##-b}" "builder")" || exit 1
				;;
			-j|--jobs)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_jobs="$2"
				shift
				;;
			--jobs=*)
				_arg_jobs="${_key##--jobs=}"
				;;
			-j*)
				_arg_jobs="${_key##-j}"
				;;
			--no-debug|--debug)
				_arg_debug="on"
				test "${1:0:5}" = "--no-" && _arg_debug="off"
				;;
			--no-derivatives|--derivatives)
				_arg_derivatives="on"
				test "${1:0:5}" = "--no-" && _arg_derivatives="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'product'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_product "
	_our_args=$((${#_positionals[@]} - 1))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_product[$((ii + 1))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash
# Validation of values



### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


to_uppercase() {
	printf '%s' "$1" | tr '[:lower:]' '[:upper:]'
}

to_lowercase() {
	printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

opt_product_in() {
	switch="-DSSG_PRODUCT_$(to_uppercase "$1")=ON"
	echo "$switch"
}

is_product() {
	local candidate="$1"
	for cmake_product in "${all_cmake_products[@]}"; do
		if test "$(to_uppercase "$candidate")" = "$cmake_product"; then
			return 0
		fi
	done

	return 1
}

build_with_ninja() {
	cmake_generator="Ninja"
	build_command="ninja"
}

build_with_make() {
	cmake_generator="Unix Makefiles"
	build_command="make"
}

autodetect_builder() {
	if command -v ninja &>/dev/null ; then
		build_with_ninja
	else
		build_with_make
	fi
}

handle_wrong_products() {
	all_cmake_lowercase=()
	for p in "${all_cmake_products[@]}"; do
		all_cmake_lowercase+=("$(to_lowercase "$p")")
	done
	possible_products=$'\n'"$(printf ' * %s\n' "${all_cmake_lowercase[@]}")"

	printf 'Choose one or more product names from the list: %s' "$possible_products"
	exit 1
}

set_no_derivatives_options() {
	test "$_arg_derivatives" = on && return
	if grep -q 'rhel' <<< "${_arg_product[*]}"; then
		CMAKE_OPTIONS+=("-DSSG_CENTOS_DERIVATIVES_ENABLED:BOOL=OFF")
	fi
	if grep -q 'rhel\(6\|7\)' <<< "${_arg_product[*]}"; then
		CMAKE_OPTIONS+=("-DSSG_SCIENTIFIC_LINUX_DERIVATIVES_ENABLED:BOOL=OFF")
	fi
}

# Get this using
# grep 'option(SSG_PRODUCT' CMakeLists.txt  | sed -e 's/option(SSG_PRODUCT_\(\w\+\).*/\1/'
all_cmake_products=(
	CHROMIUM
	DEBIAN8
	DEBIAN9
	DEBIAN10
	EAP6
	EXAMPLE
	FEDORA
	FIREFOX
	FUSE6
	JRE
	OCP3
	OCP4
	OL7
	OL8
	OPENSUSE
	RHEL6
	RHEL7
	RHEL8
	RHOSP10
	RHOSP13
	RHV4
	SLE11
	SLE12
	UBUNTU1404
	UBUNTU1604
	UBUNTU1804
	WRLINUX8
	WRLINUX1019
)

DEFAULT_OVAL_MAJOR_VERSION=5
DEFAULT_OVAL_MINOR_VERSION=11

build_type_option="-DCMAKE_BUILD_TYPE=Release"

cores=$(nproc 2>/dev/null) || cores=1


if test "$_arg_oval" = auto; then
	oval_major_version_option="-DSSG_TARGET_OVAL_MAJOR_VERSION:STRING=$DEFAULT_OVAL_MAJOR_VERSION"
	oval_minor_version_option="-DSSG_TARGET_OVAL_MINOR_VERSION:STRING=$DEFAULT_OVAL_MINOR_VERSION"
else
	oval_major_version_option="-DSSG_TARGET_OVAL_MAJOR_VERSION:STRING=$(cut -f 1 -d . <<< "$_arg_oval")"
	oval_minor_version_option="-DSSG_TARGET_OVAL_MINOR_VERSION:STRING=$(cut -f 1 -d . --complement <<< "$_arg_oval")"
fi

test "$_arg_debug" = on && build_type_option="-DCMAKE_BUILD_TYPE=Debug"

jobs="$_arg_jobs"
test "$jobs" = auto && jobs=$cores

if test "$_arg_builder" = make; then
	build_with_make
elif test "$_arg_builder" = ninja; then
	build_with_ninja
else
	autodetect_builder
fi

cmake_enable_args=()
for chosen_product in "${_arg_product[@]}"; do
	if is_product "$chosen_product"; then
		cmake_enable_args+=("$(opt_product_in "$chosen_product")")
	else
		handle_wrong_products "$chosen_product"
	fi
done

CMAKE_OPTIONS=(${ADDITIONAL_CMAKE_OPTIONS} "${build_type_option}" "${oval_major_version_option}" "${oval_minor_version_option}" '-DSSG_PRODUCT_DEFAULT=OFF' "${cmake_enable_args[@]}" -G "$cmake_generator")
set_no_derivatives_options

set -e
rm -rf build/*
cd build
cmake .. "${CMAKE_OPTIONS[@]}"
$build_command "-j${jobs}"

# ] <-- needed because of Argbash
